using System.Collections.Generic;
using System.Xml.Serialization;
using System.Collections;
using UnityEngine;
using System.Linq;
using System;

public enum ConstraintType{ FuzzyProperties, UserDefinedTags }
public enum ConstraintTarget{ AllRooms, StartRoom, EndRoom, MiddleRooms, SideRooms}
public enum ConstraintAmount{ All, AtLeast, AtMost, Exactly, None}
public enum ConstraintAmountType{ Absolute, Percentual }

[Serializable]
public class Constraint {
	protected ConstraintAmountType amountType;
	protected ConstraintTarget target;
	protected ConstraintAmount amount;
	protected ConstraintType type;
	protected List<string> parsedTags;
	protected string fuzzyTagName;
	protected float relativeAmount;
	protected int absolutAmount;
	protected int autoTagIndex;
	protected string rawTags;
	public float Min = 0f;
	public float Max = 1f;

	public Constraint(){
		parsedTags = new List<string> ();
		rawTags = "";
	}

	public void ExecuteConstraint(){
		//chunks.RemoveAll (c => !IsConstraintSatisfied (c));
	}

	public bool IsConstraintSatisfied(GameObject chunk){
		bool result = true;
		ChunkTags chunkTags = chunk.GetComponent<ChunkTags> ();

		if (type == ConstraintType.FuzzyProperties) {
			result = IsFuzzySatisfied (chunkTags);
		} else {
			result = IsUserTagsSatisfied (chunkTags);
		}
		/*ChunkTags tags = chunk.GetComponent<ChunkTags> ();
		if (tags != null) {
			List<TagInstance> tagInstances = tags.autoGenerated;
			TagInstance toTest = tagInstances.Find (ti => ti.Name == tagName);
			return toTest.Value < max && toTest.Value > min;
		}*/
		return true;
	}

	private bool IsCheckForAmount(){
		return target != ConstraintTarget.StartRoom && target != ConstraintTarget.EndRoom &&
			amount != ConstraintAmount.All && amount != ConstraintAmount.None;
	}

	private bool IsFuzzySatisfied (ChunkTags chunkTags){
		List<TagInstance> autoTags = chunkTags.autoGenerated;
		//Find the tag instance of the chunk with by the name defined in the GUI
		//It's value is then compared with min and max
		TagInstance toTest = autoTags.Find (ti => ti.Name == fuzzyTagName);
		return toTest.Value < Max && toTest.Value > Min;
	}

	private bool IsUserTagsSatisfied (ChunkTags chunkTags){
		List<TagInstance> userTags = chunkTags.userGenerated;
		TagInstance toTest = userTags.Find (ti => ti.Name == fuzzyTagName);
		return userTags.All (ut => parsedTags.Contains (ut.Name));
	}
		
	public ConstraintType Type {
		get {
			return this.type;
		}
		set {
			type = value;
		}
	}

	public ConstraintTarget Target {
		get {
			return this.target;
		}
		set {
			target = value;
		}
	}

	public int AutoTagIndex {
		get {
			return this.autoTagIndex;
		}
		set {
			autoTagIndex = value;
			fuzzyTagName = FuzzyTagDictionary.Descriptors [autoTagIndex];
		}
	}

	public string RawTags {
		get {
			return this.rawTags;
		}
		set {			
			rawTags = value;
			parsedTags = rawTags.Split (';').ToList();
		}
	}

	public List<string> ParsedTags {
		get {
			return this.parsedTags;
		}
	}

	public ConstraintAmount Amount {
		get {
			return this.amount;
		}
		set {
			amount = value;
		}
	}

	public int AbsolutAmount {
		get {
			return this.absolutAmount;
		}
		set {
			absolutAmount = value;
		}
	}

	public float RelativeAmount {
		get {
			return this.relativeAmount;
		}
		set {
			relativeAmount = value;
		}
	}

	public ConstraintAmountType AmountType {
		get {
			return this.amountType;
		}
		set {
			amountType = value;
		}
	}
}
/*
[Serializable]
public abstract class ConstraintImplementation{
	protected abstract bool IsConstraintSatisfied (GameObject chunk);
}
	
[Serializable]
public class AutoTagConstraint : ConstraintImplementation{
	string tagName;


	protected override bool IsConstraintSatisfied(GameObject chunk){
		ChunkTags tags = chunk.GetComponent<ChunkTags> ();
		if (tags != null) {
			List<TagInstance> tagInstances = tags.autoGenerated;
			TagInstance toTest = tagInstances.Find (ti => ti.Name == tagName);
			return toTest.Value < max && toTest.Value > min;
		}
		return true;
	}

	public float Min {
		get {
			return this.min;
		}
		set {
			min = value;
		}
	}

	public float Max {
		get {
			return this.max;
		}
		set {
			max = value;
		}
	}

	public string TagName {
		get {
			return this.tagName;
		}
		set {
			tagName = value;
		}
	}
}*/