using System.Collections.Generic;
using System.Xml.Serialization;
using System.Collections;
using UnityEngine;
using System.Linq;
using System;

public enum ConstraintType{ FuzzyProperties, UserDefinedTags }
public enum ConstraintTarget{ AllRooms, StartRoom, EndRoom, MiddleRooms, SideRooms}
public enum ConstraintAmount{ All, AtLeast, AtMost, Exactly, None}
public enum ConstraintAmountType{ Absolute, Percentual }

[Serializable]
public class Constraint {
	protected ConstraintAmountType amountType;
	protected ConstraintTarget target;
	protected ConstraintAmount amount;
	protected ConstraintType type;
	protected List<string> parsedTags;
	protected string fuzzyTagName;
	protected float relativeAmount;
	protected int absoluteAmount;
	protected int autoTagIndex;
	protected string rawTags;
	public float Min = 0f;
	public float Max = 1f;
	//Only used during instantiation and later reset
	private int matchingChunksUsed = 0;
	private int atMostAmount = -1;

	public Constraint(){
		parsedTags = new List<string> ();
		rawTags = "";
	}

	public bool IsConstraintSatisfied(ChunkMetadata meta, ChunkHelperProgress progress){
		ChunkTags chunkTags = meta.Chunk.GetComponent<ChunkTags> ();
		bool result = ConstraintResult (chunkTags);
	
		if (amount == ConstraintAmount.None) {
			result = !result;
		} else if (amount != ConstraintAmount.All) {
			result = HandleRoomAmount (meta, progress, result);
		}

		return result;
	}

	public bool HandleRoomAmount(ChunkMetadata meta, ChunkHelperProgress progress, bool previousResult){
		float remaining = progress.Remaining (target) + 0.0001f; //Remaining rooms that need be created
		float priorityBonus = (absoluteAmount / remaining);
		int wantedAmount = GetAmountValue (progress.TotalRoomCount (target));

		bool enoughCreated = matchingChunksUsed >= wantedAmount;
		meta.Priority += previousResult && !enoughCreated ? priorityBonus: 0f;

		if (previousResult) {
			meta.RegisterAsMatching (this);
		}

		bool stillSatisfied = true;

		switch (amount) {
		case ConstraintAmount.AtLeast:
			stillSatisfied = true;
			break;
		case ConstraintAmount.Exactly:
		case ConstraintAmount.AtMost:
			stillSatisfied = !previousResult || (previousResult && !enoughCreated);
			break;
		}

		return stillSatisfied;
	}

	private int GetAmountValue(int totalRoomCount){
		int _amountValue;
		if(amountType == ConstraintAmountType.Absolute){
			_amountValue = absoluteAmount;
		}  else{
			_amountValue = (int)Mathf.Round (relativeAmount * totalRoomCount);
		}
		if (amount == ConstraintAmount.AtMost) {
			_amountValue = (int)Mathf.Round (_amountValue * UnityEngine.Random.value);
		}
		return _amountValue;
	}

	public void MatchingChunkHasBeendUsed(){
		matchingChunksUsed++;
	}

	private bool ConstraintResult(ChunkTags chunkTags){
		bool result;
		if (type == ConstraintType.FuzzyProperties) {			
			result = IsFuzzySatisfied (chunkTags);
		} else {
			result = IsUserTagsSatisfied (chunkTags);
		}
		return result;
	}

	private bool IsCheckForAmount(){
		return target != ConstraintTarget.StartRoom && target != ConstraintTarget.EndRoom &&
			amount != ConstraintAmount.All && amount != ConstraintAmount.None;
	}

	private bool IsFuzzySatisfied (ChunkTags chunkTags){
		if (chunkTags != null) {
			List<TagInstance> autoTags = chunkTags.autoGenerated;
			//Find the tag instance of the chunk with by the name defined in the GUI
			//It's value is then compared with min and max
			TagInstance toTest = autoTags.Find (ti => ti.Descriptor == fuzzyTagName);
			return toTest.Value <= Max && toTest.Value >= Min;
		}
		return true;
	}

	private bool IsUserTagsSatisfied (ChunkTags chunkTags){
		IEnumerable<string> userTags = chunkTags.userGenerated.Select(ct => ct.Name);
		return parsedTags.All (pt => userTags.Contains (pt));
	}
		
	public ConstraintType Type {
		get {
			return this.type;
		}
		set {
			type = value;
		}
	}

	public ConstraintTarget Target {
		get {
			return this.target;
		}
		set {
			target = value;
		}
	}

	public int AutoTagIndex {
		get {
			return this.autoTagIndex;
		}
		set {
			autoTagIndex = value;
			fuzzyTagName = FuzzyTagDictionary.Descriptors [autoTagIndex];
		}
	}

	public string RawTags {
		get {
			return this.rawTags;
		}
		set {			
			rawTags = value;
			parsedTags = rawTags.Split (';').ToList();
		}
	}

	public List<string> ParsedTags {
		get {
			return this.parsedTags;
		}
	}

	public ConstraintAmount Amount {
		get {
			return this.amount;
		}
		set {
			amount = value;
		}
	}

	public int AbsoluteAmount {
		get {
			return this.absoluteAmount;
		}
		set {
			absoluteAmount = value;
		}
	}

	public float RelativeAmount {
		get {
			return this.relativeAmount;
		}
		set {
			relativeAmount = value;
		}
	}

	public ConstraintAmountType AmountType {
		get {
			return this.amountType;
		}
		set {
			amountType = value;
		}
	}

	public void ResetConstraint(){
		matchingChunksUsed = 0;
		atMostAmount = -1;
	}
}